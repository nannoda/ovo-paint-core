{
  "version": 3,
  "sources": ["src/submodules/common-ts-utils/WebWorker/CreateWorker.ts", "src/Documents/DocNodes/AbstractDocNode.ts", "src/Documents/DocNodes/BitmapLayer.ts", "src/Main.ts"],
  "sourcesContent": ["export function createWorkerFromFunction(workerFunction: () => void): Worker {\n    checkCompatibility();\n    const blob = new Blob(['(' + workerFunction.toString() + ')()'], {type: 'application/javascript'});\n    return new Worker(URL.createObjectURL(blob));\n}\n\nfunction checkCompatibility() {\n    if (window.Worker === undefined) {\n        throw new Error(\"Your browser does not support Web Workers.\");\n    }\n}\n", "export abstract class AbstractDocNode {\n    private _name: string;\n    protected abstract _content: CanvasImageSource;\n\n    isDirty: boolean = true;\n\n    offset: Vec2;\n\n    protected constructor(size: Vec2, name: string = \"Untitled\", offset: Vec2 = [0, 0]) {\n        this._name = name;\n        this.offset = offset;\n    }\n\n    get name(): string {\n        return this._name;\n    }\n\n    set name(name: string) {\n        this._name = name;\n    }\n\n    /**\n     * Get the image source that represents the rendered content of this node.\n     */\n    get content(): CanvasImageSource {\n        return this._content;\n    }\n\n    /**\n     * Render the content of this node to the render canvas.\n     */\n    render(): void {\n        if (!this.isDirty) {\n            return;\n        }\n        this.forceRender();\n    }\n\n    /**\n     * Force the node to render its content to the render canvas.\n     * Doesn't check if the node is dirty.\n     */\n    forceRender(): void {\n\n    }\n\n    abstract get width(): number ;\n\n    abstract get height(): number ;\n}\n", "import {createWorkerFromFunction} from \"../../submodules/common-ts-utils/WebWorker/CreateWorker\";\nimport {AbstractDocNode} from \"./AbstractDocNode\";\n\nfunction layerWorkerCode() {\n    let canvas: OffscreenCanvas;\n    let ctx: OffscreenCanvasRenderingContext2D;\n\n    function drawDot(pos: Vec2) {\n\n        ctx.fillStyle = \"#000000\";\n        ctx.beginPath();\n        ctx.arc(pos[0], pos[1], 5, 0, 2 * Math.PI);\n        ctx.fill();\n        console.log(\"drawDot\")\n    }\n\n    //\n    // function updateBitmap(){\n    //     let bitmap = canvas.transferToImageBitmap();\n    //     self.postMessage({\n    //         key: \"updateBitmap\",\n    //         data: bitmap,\n    //     })\n    //     ctx.drawImage(bitmap, 0, 0)\n    // }\n\n    self.onmessage = (e) => {\n        let data = e.data as LayerWorkerEvent;\n        switch (data.key) {\n            case \"setCanvas\":\n                canvas = data.data as OffscreenCanvas;\n                console.log(canvas)\n                ctx = canvas.getContext(\"2d\") as OffscreenCanvasRenderingContext2D;\n                break;\n            case \"drawDot\":\n                drawDot(data.data as Vec2)\n                break;\n            default:\n                console.log(\"Unknown event key: \" + data.key);\n        }\n    }\n}\n\ntype layerEventKey = \"setCanvas\" | \"drawDot\"\n\ninterface LayerWorkerEvent {\n    key: layerEventKey;\n    data: any;\n}\n\n\nexport class BitmapLayer extends AbstractDocNode {\n    protected _worker: Worker;\n    protected _size: Vec2;\n    protected _offset: Vec2;\n    protected _content: CanvasImageSource;\n\n    postMessage(e: LayerWorkerEvent, transfer?: Transferable[]) {\n        if (transfer !== undefined) {\n            this._worker.postMessage(e, transfer);\n            return;\n        }\n        this._worker.postMessage(e, transfer);\n    }\n    constructor(size: Vec2, offset: Vec2 = [0, 0]) {\n        super(size, \"BitmapLayer\", offset);\n        this._size = size;\n        this._offset = offset;\n\n        this._worker = createWorkerFromFunction(layerWorkerCode);\n        this._content = document.createElement(\"canvas\");\n        this._content.width = size[0];\n        this._content.height = size[1];\n\n        let canvas = this._content.transferControlToOffscreen();\n\n        this.postMessage(\n            {\n                key: \"setCanvas\",\n                data: canvas\n            }, [canvas]\n        );\n    }\n\n    drawDot(pos: Vec2) {\n        this.postMessage({\n            key: \"drawDot\",\n            data: pos\n        });\n    }\n\n\n    get height(): number {\n        return 0;\n    }\n\n    get width(): number {\n        return 0;\n    }\n}", "import {workerFunction} from \"./Worker\";\nimport {createWorkerFromFunction} from \"./submodules/common-ts-utils/WebWorker/CreateWorker\";\nimport {\n    CanvasUpdateEvent,\n    docManagerWorker,\n    DocWorkerEvent, ToolOpEvent,\n    ToolUpdateEvent\n} from \"./Documents/DocManager/DocManagerWorker\";\nimport {DotPen} from \"./PaintTools/DotPen\";\nimport {BitmapLayer} from \"./Documents/DocNodes/BitmapLayer\";\n\nconsole.log(\"Main.ts\");\n\n\nfunction main() {\n    let htmlCanvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n\n    let size:Vec2 = [3840, 2160];\n    let layer = new BitmapLayer(size);\n    htmlCanvas.width = size[0];\n    htmlCanvas.height = size[1];\n\n\n    let ctx = htmlCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\n\n    function frameUpdate() {\n        ctx.clearRect(0, 0, htmlCanvas.width, htmlCanvas.height);\n        ctx.drawImage(layer.content, 0, 0);\n        ctx.drawImage(layer.content, 0, 0);\n        ctx.drawImage(layer.content, 0, 0);\n        ctx.drawImage(layer.content, 0, 0);\n        requestAnimationFrame(frameUpdate);\n    }\n    frameUpdate();\n    htmlCanvas.onpointermove = (event) => {\n        console.log( \"pointermove\")\n        layer.drawDot([event.offsetX, event.offsetY]);\n    }\n\n\n    // let offscreenCanvas = htmlCanvas.transferControlToOffscreen();\n    //\n    // let worker = createWorkerFromFunction(docManagerWorker);\n    // worker.onmessage = (event) => {\n    //     console.log(\"Main.ts got message: \" + event.data);\n    // }\n    // let canvasEvent: CanvasUpdateEvent = {\n    //     canvas: offscreenCanvas\n    // }\n    //\n    // let docWorkerEvent: DocWorkerEvent = {\n    //     key: \"setCanvas\",\n    //     data: canvasEvent\n    // }\n    //\n    // worker.addEventListener(\"message\", (event) => {\n    //     console.log(\"Main.ts got message: \");\n    //     console.log(event.data);\n    //     console.log(event.origin);\n    // });\n    //\n    //\n    //\n    // worker.postMessage(docWorkerEvent, [offscreenCanvas]);\n    //\n    // function objectToStr(obj: any): string {\n    //     return obj[\"constructor\"].toString();\n    // }\n    //\n    // let pen = new DotPen();\n    //\n    // let penConstructorStr = objectToStr(pen);\n    //\n    // let toolEvent: ToolUpdateEvent = {\n    //     tool: penConstructorStr\n    // }\n    //\n    // console.log(penConstructorStr);\n    //\n    // docWorkerEvent = {\n    //     key: \"setTool\",\n    //     data: toolEvent\n    // }\n    //\n    // worker.postMessage(docWorkerEvent);\n    //\n    // docWorkerEvent = {\n    //     key: \"log\",\n    //     data: \"nothing\"\n    // }\n    // worker.postMessage(docWorkerEvent)\n    //\n    // function methodsToStringDict(method: any) {\n    //     let dict: any = {};\n    //     for (let key of Object.getOwnPropertyNames(Object.getPrototypeOf(method))) {\n    //         dict[key] = method[key].toString();\n    //     }\n    //     return dict;\n    // }\n    //\n    // // get all methods from pen\n    // let penDict = methodsToStringDict(pen);\n    // let methods = Object.getOwnPropertyNames(Object.getPrototypeOf(pen));\n    //\n    // console.log(pen[\"onMove\"].toString())\n    // console.log(penDict);\n    //\n    //\n    // htmlCanvas.addEventListener(\"pointermove\", (event) => {\n    //     let toolOpEvent: ToolOpEvent = {\n    //         event: {\n    //             pos: [event.offsetX, event.offsetY],\n    //             button: event.button,\n    //             type: \"move\",\n    //             pressure: event.pressure\n    //         }\n    //     }\n    //\n    //     docWorkerEvent = {\n    //         key: \"toolOp\",\n    //         data: toolOpEvent\n    //     }\n    //\n    //     worker.postMessage(docWorkerEvent);\n    // })\n    // docWorkerEvent = {\n    //     key: \"returnBitmap\",\n    //     data: \"nothing\"\n    // }\n    //\n    // worker.postMessage(docWorkerEvent)\n    //\n    // worker.addEventListener(\"message\", (event) => {\n    //     console.log(\"Main.ts got message: \");\n    //     if (event.data instanceof ImageBitmap) {\n    //         console.log(\"Main.ts got ImageBitmap\");\n    //         let newCanvas = document.createElement(\"canvas\");\n    //         newCanvas.width = event.data.width;\n    //         newCanvas.height = event.data.height;\n    //         let ctx = newCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    //         ctx.drawImage(event.data, 0, 0);\n    //         document.body.appendChild(newCanvas);\n    //     }\n    // });\n\n    // let ctx = offscreenCanvas.getContext(\"2d\") as OffscreenCanvasRenderingContext2D;\n    // ctx.fillStyle = \"red\";\n    // ctx.fillRect(0,0,100,100);\n}\n\nmain()\n\nconsole.log(\"Main.ts done.\")\n"],
  "mappings": "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",
  "names": []
}
